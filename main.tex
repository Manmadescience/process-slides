\documentclass{beamer}

\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{pifont}
\usepackage{tikz}
\usepackage{tikzsymbols}
\usepackage{booktabs}
\usepackage{minted}

\newcommand{\cmark}{\ding{51}}
\newcommand{\xmark}{\ding{55}}

\usetheme{Singapore}

\graphicspath{{./images/}{./images/logos/}}

\setbeamertemplate{itemize subitem}{$\blacktriangleright$}
%\renewcommand{\labelitemii}{$\blacktriangleright$}

\begin{document}

\title{Softwareentwicklungsprozess: \\ Vorschl"age}
\date{\today}
\author{Oleg H"ofling}
\institute[netqa]{netqa GmbH}
\logo{
	\includegraphics[scale=.05]{netqa-logo.eps}
} % end logo
\frame{\maketitle}

\frame{\frametitle{"Uberblick}\tableofcontents[hideallsubsections]}

\section{Ziele}
\subsection{Placeholder}
\begin{frame}
	\begin{itemize}
		\item[\cmark] Eigene Vorschl"age "ubermitteln
		\item[\cmark] \textbf{Konstruktive} Kritik (eher wenig)
		\item[\cmark] Aufgaben in akute und langfristige aufteilen
		\item[\cmark] Anregung zur Diskussion
	\end{itemize}
\end{frame}

\section{Joel Test}
\subsection{Placeholder}
\begin{frame}{Joel Spolsky}
	\begin{columns}[T] % align columns
		\begin{column}{.49\textwidth}
			\vfill
			\begin{center}
				\includegraphics[scale=.25]{spolsky.jpeg}
			\end{center}
			\vfill
		\end{column}
		\hfill
		\begin{column}[t]{0.49\textwidth}
			\vfill
				\includegraphics[scale=.25]{so-logo.eps}
			\vfill
				\includegraphics[scale=.25]{trello-logo-blue.eps}
			\vfill
				\includegraphics[scale=.75]{fogbugz.eps}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}{Der Joel Test}
	\begin{itemize}
		\item Einfach und schnell
		\item Es wird der \textbf{Softwareentwicklungsprozess} evaluiert
		\item 12 Fragen, ein Punkt f"ur jede \glqq{}Ja\grqq{}-Antwort
		\item Auswertung:
			\begin{description}[labelwidth=\widthof{10 Punkte:}]
				\item[12 Punkte:] \Laughey
				\item[11 Punkte:] \Neutrey
				\item[$\leqslant 10$ Punkte:] \Xey
			\end{description}
	\end{itemize}
\end{frame}

\begin{frame}{Der Joel Test, Teil I}
	\begin{enumerate}
		\item<1-> Do you use source control? \uncover<2->{\cmark}
		\item<3-> Can you make a build in one step? \uncover<4->{\xmark}
		\item<5-> Do you make daily builds? \uncover<6->{\xmark}
		\item<7-> Do you have a bug database? \uncover<8->{\cmark}
		\item<9-> Do you fix bugs before writing new code? \uncover<10->{\cmark}
		\item<11-> Do you have an up-to-date schedule? \uncover<12->{\xmark}
	\end{enumerate}
\end{frame}

\begin{frame}{Der Joel Test, Teil II}
	\begin{enumerate}
		\setcounter{enumi}{6}
		\item<1-> Do you have a spec? \uncover<2->{\xmark}
		\item<3-> Do programmers have quiet working conditions? \uncover<4->{\cmark}
		\item<5-> Do you use the best tools money can buy? \uncover<6->{\cmark}
		\item<7-> Do you have testers? \uncover<8->{\cmark}
		\item<9-> Do new candidates write code during their interview? \uncover<10->{\xmark}
		\item<11-> Do you do hallway usability testing? \uncover<12->{\xmark}
	\end{enumerate}
\end{frame}

\begin{frame}{Ergebnis}
	\begin{center}
		\includegraphics[scale=.25]{sad-kid.jpg}
	\end{center}
\end{frame}

\section{Operative Ziele}
\subsection{Placeholder}
\begin{frame}{Git Flow}
	\begin{columns}[T] % align columns
		\begin{column}{.2\textwidth}
			\resizebox{!}{.8\textheight}{
					\input{git-mess}
			}
		\end{column}
		\hfill
		\begin{column}{.8\textwidth}
			\vfill
			\begin{itemize}
				\item<1-> So sieht's im Moment aus
				\item<1-> Keine Struktur zu erkennen
				\item<1-> Futter f"ur Mergekonflikte
				\item<1-> Fehlersuche mit \texttt{git bisect} wird erschwert
				\item<2->[] \fbox{\includegraphics[scale=.33]{git-rebase-coming.jpg}}
			\end{itemize}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}{Git Flow}
	\begin{center}
		\resizebox{!}{.8\textheight}{
			\input{git-flow}
		}
	\end{center}
\end{frame}

\begin{frame}{Git Flow}
	\begin{center}
		Man kann es weiter ausbauen$\ldots$
		
		\includegraphics[height=.8\textheight]{git-model.png}
	\end{center}
\end{frame}

\begin{frame}{Git Flow}
	\begin{itemize}
		\item Prozess in Trello (vollst"andig?) dokumentiert
		\item Kleine Commits (duh!)
		\item Sinnvolle Branchnamen und Commit Messages
		\item[] Insbesondere \texttt{indev\char`_py3} umbenennen
		\item Branchname als Prefix im Commit Message
	\end{itemize}
\end{frame}

\begin{frame}{Git Flow}
	\only<1>{
		\resizebox{!}{.6\textheight}{
			\input{git-branch-no-names}
		}
	}
	\only<2>{
		\resizebox{!}{.6\textheight}{
			\input{git-branch-names}
		}
	}
\end{frame}

\begin{frame}{Git Flow}
	\begin{columns}[T] % align columns
		\begin{column}{.4\textwidth}
			\begin{center}
				\includegraphics[scale=.2]{progit.png}
			\end{center}
		\end{column}
		\hfill
		\begin{column}{.8\textwidth}
			\vfill
			\begin{itemize}
				\item \texttt{Git Command Line} verwenden
				\item Terminal einrichten
					\begin{itemize}
						\item Tab-Vervollst"andigung
						\item Vorw"arts-/R"uckw"artssuche im Command Log
						\item Farben
					\end{itemize}
				\item Repo Browser verwenden
					\begin{description}[Windows]
						\item[Windows] GitExtensions, SourceTree
						\item[Linux] gitg, git-cola
					\end{description}
				\item Handbuch: Pro Git, 2nd Edition (kostenlos!)
			\end{itemize}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}{Statische Codeanalyse}
	\begin{itemize}
		\item Einheitliche Formatierung
			\begin{itemize}
				\item Ein Tab ist 4 Leerzeichen lang
				\item Klassen: \texttt{CamelCase}
				\item Variablen: \texttt{lower\char`_case\char`_with\char`_underscores}
				\item Keine Leerzeichen am Zeilenende
				\item \texttt{text = 'netqa'} oder \texttt{text = "netqa"}?
			\end{itemize}
		\item Potenzielle Bugs fr"uh abfangen
		\item Unn"otige Merge-Konflikte vermeiden
		\item Disziplin
	\end{itemize}
\end{frame}

\begin{frame}{Statische Codeanalyse: Python}
	\begin{itemize}
		\item Minimalsatz an Regeln ausarbeiten		
		\item \texttt{PEP\,8} und \texttt{Pylint}
		\item Automatisches Stylechecking vor dem Commit bereits eingerichtet (\texttt{origin/git-repo-setup})
		\item Aktuell 1554 Verletzungen
		\item \texttt{Pylint} bietet Code-Rating an:
	\end{itemize}
	\begin{center}
		\begin{minipage}{.8\textwidth}
			\texttt{Global evaluation}

			\texttt{-----------------}

			\texttt{Your code has been rated at 6.02/10 (previous run: 6.46/10, -0.44)}
		\end{minipage}
	\end{center}
\end{frame}

\begin{frame}{Statische Codeanalyse: Javascript}
	\begin{itemize}
		\item Anwendung:
			\begin{itemize}
				\item Dashboard \cmark
				\item Reports?
			\end{itemize}
		\item Kein etablierter Linter
		\item Strict-Mode f"ur JS-Compilers:
		\item[] \texttt{'use strict';}
	\end{itemize}
\end{frame}

\begin{frame}{Code Review}
	\begin{itemize}
		\item In einer idealen Welt: immer
		\item Vier-Augen-Prinzip
		\item Kann z.\,B. durch Scrum erzwungen werden
	\end{itemize}
\end{frame}

\begin{frame}{Nightly Builds}
	\begin{itemize}
		\item Build = Endprodukt
		\item Der Build-Prozess fehlt!
		\item Standalone Installer?
		\item Web Service Deployment?
		\item $\ldots$?
	\end{itemize}
\end{frame}

\begin{frame}{Nightly Builds}
	Minimale Integration in Jenkins:
	\begin{itemize}
		\item Cron-Job, startet um 23 Uhr
		\item Baut \texttt{develop} und \texttt{release/master}
		\item Setzt Tags in \texttt{Git} (Version usw)
		\item F"uhrt Unit Tests aus
		\item F"uhrt Systemtests aus
		\item Report wird am n"achsten Morgen evaluiert
		\item Standalone: Stabile Builds werden Kunden zum Download angeboten
		\item Web Service: Deployment auf den Production Server
		\item Build"ubergreifende Metriken auswerten
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Tests}
	\begin{itemize}
		\item Aktuell: 62\% Abdeckung
		\item Gar nicht mal so "ubel, wenn \texttt{coverage} richtig liegt
		\item Systemtests (wenn der Build-Prozess steht)
	\end{itemize}
	
	\begin{overprint}
	\onslide<1>
	\begin{minted}{bash}
	$ nosetests --with-coverage \
		--cover-package=NetqaFwRoot
	---------------------------
	Name   Stmts   Miss   Cover
	TOTAL  1545    592    62%
	---------------------------
	Ran 53 tests in 20.421s
	FAILED (SKIP=1, errors=8)
	\end{minted}
	
	\onslide<2>
	\begin{minted}{bash}
	$ find NetqaFwRoot/ -type f -iname '*.py' \
		-not -path "*/tests/*" \
		| xargs sed '/^\s*#/d;/^\s*$/d' \
		| wc -l
	4846
	\end{minted}
	\end{overprint}
\end{frame}

\begin{frame}{Versionierung}
	\begin{equation*}
		\underbrace{\underbrace{\underbrace{1}_{\text{Major}}.\underbrace{5}_{\text{Minor}}}_{\text{Release}}.\underbrace{11}_{\text{Features}}.\underbrace{255}_{\text{Survived Days}}}_{\text{Develop}}
	\end{equation*}
	\vfill
	\begin{description}[Survived Days:]
		\item[Major:] Version vom letzten Release
		\item[Minor:] Bugfixing-Releases
		\item[Features:] Anzahl Features im aktuellen Develop
		\item[Survived Days:] Anzahl Tage seit dem letzten Release
		\item[Ansonsten:] \texttt{PEP\,396 -- Module Version Numbers}
	\end{description}
\end{frame}

\section{Strategische Ziele}
\subsection{Placeholder}

\begin{frame}{"Ubersicht}
	\begin{itemize}
		\item Specification-Dokument
			\begin{itemize}
				\item Systemanforderungen
				\item Funktionalit"at
				\item Interfaces nach au"sen
				\item Screenshots vom GUI bzw. Mockups
				\item "Anderungen werden auch versioniert
			\end{itemize}
		\item Agiler Prozess
			\begin{itemize}
				\item Zu umfangreich -- separate Pr"asi?
				\item (Au"serdem keine guten Folien vorbereitet \Sadey)
				\item Kommt erst nach dem Spec
			\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{Agiler Prozess}
	\begin{itemize}
		\item Ziel: schnell Ergebnisse liefern
		\item Ein Entwicklungszyklus wird in 2-3 Wochen abgeschlossen (Rolling Release)
		\item Deckt ab:
			\begin{itemize}
				\item Projektplanung
				\item Zeitmanagement
				\item Bugfixing
				\item Implementation von neuen Features
			\end{itemize}
		\item $\text{Scrum} + \text{JIRA} = \Laughey$, $\text{Kanban} + \text{Trello} = \Neutrey$, $\ldots$?
	\end{itemize}
\end{frame}

\begin{frame}{Scrum-Zyklus}
	\begin{center}
		\includegraphics[scale=.25]{scrum-process.eps}
	\end{center}
\end{frame}

\begin{frame}{Ticket-Lebenszyklus}
	\begin{center}
		\includegraphics[scale=.5]{jira-ticket-lifecycle.png}
	\end{center}
\end{frame}

\begin{frame}{Scrum, Regeln}
	\begin{itemize}
		\item Alle Bugs werden im Bug Tracker persistiert
		\item M"undlich berichtete Bugs (\glqq{}Den Fehler habe ich doch schon vor Wochen gesehen$\ldots$\grqq) werden ignoriert
		\item Alle Ideen werden im Product Backlog persistiert
		\item M"undlich ge"au"serte W"unsche (\glqq{}Kannst Du noch schnell ein Button einbauen?$\ldots$\grqq) werden ignoriert
		\item B"urokratie \xmark
		\item Aber: Nach der Gew"ohnungsphase dauert das Erstellen von Tickets selten mehr als 5 Minuten
		\item Nichts geht verloren \cmark
	\end{itemize}
\end{frame}

\begin{frame}{Nightly Builds, Revisited}
	Erweiterte Integration mit Jenkins:
	\begin{itemize}
		\item Ein zus"atlicher Verifikationsschritt im Ticket-Lebenszyklus durch Jenkins
		\item Sammelt alle am Tag verifizierten Tickets
		\item Solange ein Fehler beim Testen auftritt:
			\begin{itemize}
				\item Findet fehlerhaften Commit mit \texttt{git bisect}
				\item Ordnet den Commit dem Ticket zu
				\item "Offnet das Ticket
			\end{itemize}
		\item Schlie"st alle nicht wiederge"offneten Tickets endg"ultig
	\end{itemize}
	Bessere Integration: $\text{Bamboo} + \text{JIRA}$
\end{frame}

\end{document}
